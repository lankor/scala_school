<p>Esta lección cubre la creación de pruebas con Specs, un Framework de Diseño Dirigido por Comportamiento (Behavior-Driven Design, <span class="caps">BDD</span>) para Scala.</p>
<ul>
	<li><a href="#example">extendiendo la clase Specification</a>
	<ul>
		<li>ejemplos anidados</li>
	</ul></li>
	<li><a href="#scope">Modelo de Ejecución</a></li>
	<li><a href="#setup">Setup y TearDown</a>
	<ul>
		<li>doFirst</li>
		<li>doBefore</li>
		<li>doAfter</li>
	</ul></li>
	<li><a href="#matchers">Comparadores</a>
	<ul>
		<li>mustEqual</li>
		<li>contains</li>
		<li>sameSize?</li>
		<li>Escribe tu comparador</li>
	</ul></li>
	<li><a href="#mocks">Mocks</a></li>
	<li><a href="#spies">Spies</a></li>
	<li><a href="#sbt">Ejecución con sbt</a></li>
</ul>
<h2 id="example">Extendiendo la clase Specification</h2>
<p>Comencemos.</p>
<pre>
import org.specs._

object ArithmeticSpec extends Specification {
  "Arithmetic" should {
    "sumar dos números" in {
      1 + 1 mustEqual 2
    }
    "sumar tres números" in {
      1 + 1 + 1 mustEqual 3
    }
  }
}
</pre>
<p>La clase <strong>Arithmetic</strong> es el <strong>Sistema Bajo Especificación</strong></p>
<p><strong>sumar</strong> es un contexto.</p>
<p><strong>sumar dos números</strong> y <strong>sumar tres números</strong> son ejemplos.</p>
<p><code>mustEqual</code> indica una <strong>expectativa</strong></p>
<p><code>1 mustEqual 1</code> es una referencia de <strong>expectativa</strong> común, que se usa antes de que empieces a escribir pruebas reales. Todos los ejemplos deben tener por lo menos una expectativa.</p>
<h3>Duplicación</h3>
<p>¿Te das cuenta como las dos pruebas tienen la palabra <code>sumar</code> en el nombre? Podemos eliminarlas <strong>anidando</strong> expectativas.</p>
<pre>
import org.specs._

object ArithmeticSpec extends Specification {
  "Arithmetic" should {
    "sumar" in {
      "dos números" in {
        1 + 1 mustEqual 2
      }
      "tres números" in {
        1 + 1 + 1 mustEqual 3
      }
    }
  }
}
</pre>
<h2 id="scope">Modelo de ejecución</h2>
<pre>
object ExecSpec extends Specification {
  "Las modificaciones están aisladas" should {
    var x = 0
    "x solo es igual a 1 si lo cambiamos." in {
      x = 1
      x mustEqual 1
    }
    "x tendrá el valor por defecto si no lo modificamos" in {
      x mustEqual 0
    }
  }
}
</pre>
<h2 id="setup">Setup, Teardown</h2>
<h3>doBefore &amp; doAfter</h3>
<pre>
"mi sistema" should {
  doBefore { resetTheSystem() /** función definida por el usuario para restablecer el sistema */ }
  "desordenar el sistema" in {...}
  "una vez más" in {...}
  doAfter { cleanThingsUp() }
}
</pre>
<p><strong><span class="caps">NOTA</span></strong> <code>doBefore</code>/<code>doAfter</code> sólo se ejecutan en los ejemplos hoja, no en los anidados.</p>
<h3>doFirst &amp; doLast</h3>
<p><code>doFirst</code>/<code>doLast</code> se usan para configurar una única vez. (hace falta un ejemplo, yo no uso esto)</p>
<pre>
"Foo" should {
  doFirst { openTheCurtains() }
  "probar métodos sin estado" in {...}
  "probar otros métodos sin estado" in {...}
  doLast { closeTheCurtains() }
}
</pre>
<h2 id="matchers">Comparadores</h2>
<p>Tienes datos, y quieres asegurar que son los correctos. Hagamos un tour por los comparadores más conocidos. (Revisa también la <a href="http://code.google.com/p/specs/wiki/MatchersGuide">Guía de comparadores</a>)</p>
<h3>mustEqual</h3>
<p>Ya hemos visto varios ejemplos del comparador mustEqual.</p>
<pre>
1 mustEqual 1

"a" mustEqual "a"
</pre>
<p>Igualdad de referencia, igualdad de valor.</p>
<h3>Elementos en una secuencia</h3>
<pre>
val numbers = List(1, 2, 3)

numbers must contain(1)
numbers must not contain(4)

numbers must containAll(List(1, 2, 3))
numbers must containInOrder(List(1, 2, 3))

List(1, List(2, 3, List(4)), 5) must haveTheSameElementsAs(List(5, List(List(4), 2, 3), 1))
</pre>
<h3>Elementos en un mapa</h3>
<pre>
map must haveKey(k)
map must notHaveKey(k)

map must haveValue(v)
map must notHaveValue(v)
</pre>
<h3>Números</h3>
<pre>
a must beGreaterThan(b)
a must beGreaterThanOrEqualTo(b)

a must beLessThan(b)
a must beLessThanOrEqualTo(b)

a must beCloseTo(b, delta)
</pre>
<h3>Opciones</h3>
<pre>
a must beNone

a must beSome[Type]

a must beSomething

a must beSome(value)
</pre>
<h3>throwA</h3>
<pre>
a must throwA[WhateverException]
</pre>
<p>Es más corto que un try catch con un fail dentro del try.</p>
<p>También puedes esperar un mensaje de excepción expecífico</p>
<pre>
a must throwA(WhateverException("message"))
</pre>
<p>También puedes usar comparadores con la excepción:</p>
<pre>
a must throwA(new Exception) like {
  case Exception(m) =&gt; m.startsWith("bad")
}
</pre>
<h3>Escribe tus propios comparadores</h3>
<pre>
import org.specs.matcher.Matcher
</pre>
<h4>Como un val</h4>
<pre>
"Un comparador" should {
  "poder crearse como un val" in {
    val beEven = new Matcher[Int] {
      def apply(n: =&gt; Int) = {
        (n % 2 == 0, "%d is even".format(n), "%d is odd".format(n))
      }
    }
    2 must beEven
  }
}
</pre>
<p>El contrato es devolver una tupla que indique si la comparación resultó verdadera, y dos mensajes uno para el caso verdadero y otro para el falso.</p>
<h4>Como una clase case</h4>
<pre>
case class beEven(b: Int) extends Matcher[Int]() {
  def apply(n: =&gt; Int) =  (n % 2 == 0, "%d is even".format(n), "%d is odd".format(n))
}
</pre>
<p>Usando una clase caso, el comparador es más fácil de compartir.</p>
<h2 id="mocks">Mocks</h2>
<pre>
import org.specs.Specification
import org.specs.mock.Mockito

class Foo[T] {
  def get(i: Int): T
}

object MockExampleSpec extends Specification with Mockito {
  val m = mock[Foo[String]]

  m.get(0) returns "one"

  m.get(0)

  there was one(m).get(0)

  there was no(m).get(1)
}
</pre>
<p><strong>Revisa también</strong> <a href="http://code.google.com/p/specs/wiki/UsingMockito">Cómo usar Mockito</a></p>
<h2 id="spies">Spies</h2>
<p>Los espías se pueden usar para hacer &#8220;mocking parcial&#8221; de objetos reales:</p>
<pre>
val list = new LinkedList[String]
val spiedList = spy(list)

// los métodos también pueden reemplazarse en un espía
spiedList.size returns 100

// también se pueden usar otros métodos
spiedList.add("one")
spiedList.add("two")

// también se puede verificar un espía
there was one(spiedList).add("one")
</pre>
<p>Sin embargo, trabajar con espías puede ser complicado:</p>
<pre>
// si la lista está vacía, esto lanzará una excepción IndexOutOfBoundsException
spiedList.get(0) returns "one"
</pre>
<p>Se debe usar <code>doReturn</code> en ese caso:</p>
<pre>
doReturn("one").when(spiedList).get(0)
</pre>
<h2 id="sbt">Ejecuta specs individuales con sbt</h2>
<pre>
&gt; test-only com.twitter.yourservice.UserSpec
</pre>
<p>Ejecutará sólo es spec.</p>
<pre>
&gt; ~ test-only com.twitter.yourservice.UserSpec
</pre>
<p>Ejecutará ese test dentro de un ciclo, con cada modificación al archivo, se ejecutará nuevamente la prueba.</p>