<p>Scala ofrece una buena implementación de colecciones. También proporciona abstracciones para algunos tipos de colecciones. Esto te permite escribir código que pueda funcionar con una colección de <code>Foo</code>s (cualquier tipo) sin preocuparte si la colección es una <code>List</code>, <code>Set</code>, o cual sea que tengas.</p>
<p><a href="http://www.decodified.com/scala/collections-api.xml">Esta página</a> ofrece una gran forma de seguir las implementaciones predeterminadas y enlaces a toda la documentacion de Scala (scaladoc).</p>
<ul>
	<li><a href="#basics">Básicos</a> Tipos de Colecciones que usarás todo el tiempo</li>
	<li><a href="#hierarchy">Jerarquía</a> Abstracción de Colecciones</li>
	<li><a href="#methods">Métodos</a></li>
	<li><a href="#mutable">Mutable</a></li>
	<li><a href="#java">Colecciones de Java</a> Simplemente funcionan</li>
</ul>
<h2 id="basics">Los básicos</h2>
<h3>Listas (List)</h3>
<p><code>list</code> La lista ligada estándar.</p>
<pre>
scala&gt; List(1, 2, 3)
res0: List[Int] = List(1, 2, 3)
</pre>
<p>Tú puedes usar cons(<code>::</code>) tal como esperarías en un lenguaje funcional.<br />
<i>cons</i> añade un elemento al inicio de una lista.</p>
<pre>
scala&gt; 1 :: 2 :: 3 :: Nil
res1: List[Int] = List(1, 2, 3)
</pre>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/List.html"><span class="caps">API</span> doc</a></p>
<h3>Conjuntos (Set)</h3>
<p>Los conjuntos <code>set</code> no tienen elementos duplicados.</p>
<pre>
scala&gt; Set(1, 1, 2)
res2: scala.collection.immutable.Set[Int] = Set(1, 2)
</pre>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Set.html"><span class="caps">API</span> doc</a></p>
<h3>Secuencias (Seq)</h3>
<p>Las secuencias <code>seq</code> tienen un orden definido.</p>
<pre>
scala&gt; Seq(1, 1, 2)
res3: Seq[Int] = List(1, 1, 2)
</pre>
<p>(Nótese que devuelve una Lista. <code>Seq</code> es un rasgo (trait); List es una adorable implementación de Seq. Hay una fábrica de objetos <code>Seq</code> que, como podrás ver aquí, crea listas.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/Seq.html"><span class="caps">API</span> doc</a></p>
<h3>Mapas (Map)</h3>
<p>Los Mapas <code>maps</code> son contenedores de claves con valores.</p>
<pre>
scala&gt; Map('a' -&gt; 1, 'b' -&gt; 2)
res4: scala.collection.immutable.Map[Char,Int] = Map((a,1), (b,2))
</pre>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map.html"><span class="caps">API</span> doc</a></p>
<h2 id="hierarchy">La jerarquía</h2>
<p>Éstos son todos los rasgos (traits), tanto los paquetes mutables e immutables tienen implementaciones de éstos así como también implementaciones especializadas.</p>
<h3>Recorrible (Traversable)</h3>
<p>Todas las colecciones pueden ser recorribles. Este rasgo define funciones de recorridos estándar. Estos recorridos están escritos en términos de <code>foreach</code>, el cúal las colecciones deben implementar.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/Traversable.html"><span class="caps">API</span> doc</a></p>
<h3>Iterable (Iterable)</h3>
<p>Tiene un método <code>iterator()</code> que devuelve un Iterador para recorrer los elementos.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/Iterable.html"><span class="caps">API</span> doc</a></p>
<h3>Secuencia (Seq)</h3>
<p>Secuencia de objetos con ordenamiento.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/Seq.html"><span class="caps">API</span> doc</a></p>
<h3>Conjunto (Set)</h3>
<p>Una colección de objetos no duplicados.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Set.html"><span class="caps">API</span> doc</a></p>
<h3>Mapa (Map)</h3>
<p>Pares de claves con valores.</p>
<p><strong>Véase también</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Map.html"><span class="caps">API</span> doc</a></p>
<h2 id="methods">Los métodos</h2>
<h3>Recorrible (Traversable)</h3>
<p>Todos los métodos siguientes están disponibles en todo el camino. El tipo de parámetro y el tipo de retorno no siempre será el mismo, ya que las subclases son libres de sobreescribirlos.</p>
<pre>
def head : A
def tail : Traversable[A]
</pre>
<p>Aquí es donde los recorridos funcionales son definidos.</p>
<p><code>
def map [B] (f: (A) =&gt; B) : CC[B]
</code></p>
<p>devuelve una colección con cada elemento transformada por <code>f</code></p>
<p><code>
def foreach[U](f: Elem =&gt; U): Unit
</code></p>
<p>ejecuta <code>f</code> en cada elemento de una colección.</p>
<p><code>
def find (p: (A) =&gt; Boolean) : Option[A]
</code></p>
<p>devuelve el primer elemento que coincida con la función p</p>
<p><code>
def filter (p: (A) =&gt; Boolean) : Traversable[A]
</code></p>
<p>devuelve una colección con todos los elementos que coincidan con la función p</p>
<p>Particiones:</p>
<p><code>
def partition (p: (A) ⇒ Boolean) : (Traversable[A], Traversable[A])
</code></p>
<p>Divide una colección en dos mitades basandose en la función p</p>
<p><code>
def groupBy [K] (f: (A) =&gt; K) : Map[K, Traversable[A]]
</code></p>
<p>Conversión:</p>
<p>Curiosamente, tu puedes convertir de un tipo de colección a otra.</p>
<pre>
def toArray : Array[A]
def toArray [B &gt;: A] (implicit arg0: ClassManifest[B]) : Array[B]
def toBuffer [B &gt;: A] : Buffer[B]
def toIndexedSeq [B &gt;: A] : IndexedSeq[B]
def toIterable : Iterable[A]
def toIterator : Iterator[A]
def toList : List[A]
def toMap [T, U] (implicit ev: &lt;:&lt;[A, (T, U)]) : Map[T, U]
def toSeq : Seq[A]
def toSet [B &gt;: A] : Set[B]
def toStream : Stream[A]
def toString () : String
def toTraversable : Traversable[A]
</pre>
<p>Vamos a convertir un Mapa a un Arreglo(Array). Tú obtendrás un arreglo de claves con valores.</p>
<pre>
scala&gt; Map(1 -&gt; 2).toArray
res41: Array[(Int, Int)] = Array((1,2))
</pre>
<h3>Iterable (Iterable)</h3>
<p>Añade el acceso a un iterador.</p>
<pre>
  def iterator: Iterator[A]
</pre>
<p>¿Qué te proporciona un Iterador?</p>
<pre>
def hasNext(): Boolean
def next(): A
</pre>
<p>Esto es muy estilo Java. Tú usualmente no verás que se usen iteradores en Scala, posiblemente verás más recorridos funcionales o comprensiones-for.</p>
<h3>Conjuntos (Set)</h3>
<pre>
  def contains(key: A): Boolean
  def +(elem: A): Set[A]
  def -(elem: A): Set[A]
</pre>
<h3>Map</h3>
<p>Secuencia de pares de claves con valor con busqueda por clave.</p>
<p>Pasa una Lista de Pares a apply() como se ve</p>
<pre>
scala&gt; Map("a" -&gt; 1, "b" -&gt; 2)
res0: scala.collection.immutable.Map[java.lang.String,Int] = Map((a,1), (b,2))
</pre>
<p>O también así:</p>
<pre>
scala&gt; Map(("a", 2), ("b", 2))
res0: scala.collection.immutable.Map[java.lang.String,Int] = Map((a,2), (b,2))
</pre>
<h6>Digresión (Digression)</h6>
<p>Qué es <code>-&gt;</code>? Ésta no es una sintaxis especial. Es un método que devuelve una Tupla.</p>
<pre>
scala&gt; "a" -&gt; 2

res0: (java.lang.String, Int) = (a,2)
</pre>
<p>Recuerda, esto sólo es la forma dulce de</p>
<pre>
scala&gt; "a".-&gt;(2)

res1: (java.lang.String, Int) = (a,2)
</pre>
<p>Tú puedes también construirlo usando <code>++</code></p>
<pre>
scala&gt; Map.empty ++ List(("a", 1), ("b", 2), ("c", 3))
res0: scala.collection.immutable.Map[java.lang.String,Int] = Map((a,1), (b,2), (c,3))
</pre>
<h3>Subclases comunmente usadas</h3>
<p><strong>HashSet and HashMap</strong> Vistazo rápido a las formas más usadas de estas colecciones. <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/HashSet.html">HashSet <span class="caps">API</span></a>, <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/HashMap.html">HashMap <span class="caps">API</span></a></p>
<p><strong>TreeMap</strong> Una subclase de SortedMap, te brinda acceso ordenado. <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/TreeMap.html">TreeMap <span class="caps">API</span></a></p>
<p><strong>Vector</strong> Rápida selección aleatoria y rápida actualización de valores. <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Vector.html">Vector <span class="caps">API</span></a></p>
<pre>
scala&gt; IndexedSeq(1, 2, 3)
res0: IndexedSeq[Int] = Vector(1, 2, 3)
</pre>
<p><strong>Range</strong> Secuencia ordenada de Enteros que están separados. Tú los verás frecuentemente usarse en contadores de ciclos for.<br />
 <a href="http://www.scala-lang.org/api/current/scala/collection/immutable/Range.html">Range <span class="caps">API</span></a></p>
<pre>
scala&gt; for (i &lt;- 1 to 3) { println(i) }
1
2
3
</pre>
<p>Los rangos tienen los recorridos funcionales estándar disponibles.</p>
<pre>
scala&gt; (1 to 3).map { i =&gt; i }
res0: scala.collection.immutable.IndexedSeq[Int] = Vector(1, 2, 3)
</pre>
<h3>Por defecto</h3>
<p>Al usar métodos apply en los rasgos obtendrás una instancia de la implementación por defecto, Por ejemplo, Iterable(1, 2) devuelve una Lista como implementación por defecto.</p>
<pre>
scala&gt; Iterable(1, 2)

res0: Iterable[Int] = List(1, 2)
</pre>
<p>Al igual que con Secuencias (Seq), como vimos anteriormente</p>
<pre>
scala&gt; Seq(1, 2)
res3: Seq[Int] = List(1, 2)

scala&gt; Iterable(1, 2)
res1: Iterable[Int] = List(1, 2)

scala&gt; Sequence(1, 2)
warning: there were deprecation warnings; re-run with -deprecation for details
res2: Seq[Int] = List(1, 2)
</pre>
<p>Conjuntos (Set)</p>
<pre>
scala&gt; Set(1, 2)
res31: scala.collection.immutable.Set[Int] = Set(1, 2)
</pre>
<h3>Algunos rasgos descriptivos</h3>
<p><strong>IndexedSeq</strong> Acceso aleatorio rápido a los elementos y operaciones rápidas. <a href="http://www.scala-lang.org/api/current/scala/collection/IndexedSeq.html"><span class="caps">API</span> doc</a></p>
<p><strong>LinearSeq</strong> Acceso rápido sólo al primer elemento usando head, pero también operaciones con uso de cola rápidas. <a href="http://www.scala-lang.org/api/current/scala/collection/LinearSeq.html"><span class="caps">API</span> doc</a></p>
<h4>Mutable vs. Immutable</h4>
<p>Immutable</p>
<p>Pros</p>
<ul>
	<li>No se puede cambiar en múltiples hilos</li>
</ul>
<p>Contras</p>
<ul>
	<li>No se puede cambiar en absoluto</li>
</ul>
<p>Scala nos permite ser pragmáticos, promueve la immutabilidad, pero no nos penaliza por necesitar mutabilidad. Esto es muy similar a var vs. val. Nosotros siempre comenzaremos con val y regresaremos a var cuando sea requerido.</p>
<p>Nosotros preferimos comenzar con las versiones inmutables de las colecciones, pero cambiaremos a las mutables si el rendimiento así lo dicta. Usar colecciones inmutables significa que tú no podrás cambiar cosas accidentalmente en múltiples hilos.</p>
<h2 id="mutable">Mutable</h2>
<p>Toda las clases discutidas anteriormente eran inmutables.  Vamos a discutir las clases mutables comúnmente más usadas.</p>
<p><strong>HashMap</strong> define <code>getOrElseUpdate</code>, <code>+=</code> <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/HashMap.html">HashMap <span class="caps">API</span></a></p>
<pre>
scala&gt; val numbers = collection.mutable.Map(1 -&gt; 2)
numbers: scala.collection.mutable.Map[Int,Int] = Map((1,2))

scala&gt; numbers.get(1)
res0: Option[Int] = Some(2)

scala&gt; numbers.getOrElseUpdate(2, 3)
res54: Int = 3

scala&gt; numbers
res55: scala.collection.mutable.Map[Int,Int] = Map((2,3), (1,2))

scala&gt; numbers += (4 -&gt; 1)
res56: numbers.type = Map((2,3), (4,1), (1,2))
</pre>
<p><strong>ListBuffer and ArrayBuffer</strong> Define <code>+=</code> <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/ListBuffer.html">ListBuffer <span class="caps">API</span></a>, <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/ArrayBuffer.html">ArrayBuffer <span class="caps">API</span></a></p>
<p><strong>LinkedList and DoubleLinkedList</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/LinkedList.html">LinkedList <span class="caps">API</span></a>, <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/DoubleLinkedList.html">DoubleLinkedList <span class="caps">API</span></a></p>
<p><strong>PriorityQueue</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/PriorityQueue.html"><span class="caps">API</span> doc</a></p>
<p><strong>Stack and ArrayStack</strong> <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/Stack.html">Stack <span class="caps">API</span></a>, <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/ArrayStack.html">ArrayStack <span class="caps">API</span></a></p>
<p><strong>StringBuilder</strong> Interesantemente, StringBuilder es una colección. <a href="http://www.scala-lang.org/api/current/scala/collection/mutable/StringBuilder.html"><span class="caps">API</span> doc</a></p>
<h2 id="java">Viviendo con Java</h2>
<p>Tú puedes fácilmente moverte entre tipos de colecciones de Java y Scala usando conversiones que están disponibles en el <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.JavaConverters$">paquete JavaConverters</a>. Éstas decoran colecciones comúnmente usadas en Java con métodos <code>asScala</code> y colecciones de Scala con métodos <code>asJava</code>.</p>
<pre>
   import scala.collection.JavaConverters._
   val sl = new scala.collection.mutable.ListBuffer[Int]
   val jl : java.util.List[Int] = sl.asJava
   val sl2 : scala.collection.mutable.Buffer[Int] = jl.asScala
   assert(sl eq sl2)
</pre>
<p>Conversiones bidireccionales:</p>
<pre>
scala.collection.Iterable &lt;=&gt; java.lang.Iterable
scala.collection.Iterable &lt;=&gt; java.util.Collection
scala.collection.Iterator &lt;=&gt; java.util.{ Iterator, Enumeration }
scala.collection.mutable.Buffer &lt;=&gt; java.util.List
scala.collection.mutable.Set &lt;=&gt; java.util.Set
scala.collection.mutable.Map &lt;=&gt; java.util.{ Map, Dictionary }
scala.collection.mutable.ConcurrentMap &lt;=&gt; java.util.concurrent.ConcurrentMap
</pre>
<p>Además, de proporcionarse las siguientes conversiones unidireccionales:</p>
<pre>
scala.collection.Seq =&gt; java.util.List
scala.collection.mutable.Seq =&gt; java.util.List
scala.collection.Set =&gt; java.util.Set
scala.collection.Map =&gt; java.util.Map
</pre>