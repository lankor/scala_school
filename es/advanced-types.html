<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Scala School - Tipos Avanzados</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link rel="stylesheet" href="/scala_school/bootstrap-1.1.0.min.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-39101739-7', 'twitter.github.io');
      ga('send', 'pageview');

    </script>
  </head>

  <body>
  
    <div class="topbar">
      <div class="fill">
        <div class="container fixed">
          <h3><a href="index.html">Tipos Avanzados</a></h3>
          <ul class="nav secondary-nav">
            
              <li><a href="type-basics.html">&laquo;Previous</a></li>
            
            
              <li><a href="sbt.html">Next&raquo;</a></li>
            
          </ul>

        </div>
      </div>
    </div>

    <div class="container" style="padding-top: 60px;">
      <p>Esta lección cubre:</p>
<ul>
	<li><a href="#viewbounds">Límites de vistas</a> (&#8220;clases tipo&#8221;)</li>
	<li><a href="#otherbounds">Otros límites de tipo</a></li>
	<li><a href="#higher">Tipos de orden superior y polimorfismo ad-hoc</a></li>
	<li><a href="#fbounded">Polimorfismo con límite F / tipos recursivos</a></li>
	<li><a href="#structural">Tipos estructurales</a></li>
	<li><a href="#abstractmem">Miembros abstractos de tipos</a></li>
	<li><a href="#manifest">Borrado de tipos y manifiestos</a></li>
	<li><a href="#finagle">Caso de estudio:Case study: Finagle</a></li>
</ul>
<h2 id="viewbounds">Límites de vistas (&#8220;clases tipo&#8221;)</h2>
<p>A veces no necesitas especificar que un tipo es igual/subtipo/supertipo de otro, solo simularlo con conversiones. Un límite de vista especifíca un tipo que puede ser &#8220;visto&#8221; como otro. Esto tiene sentido en una operación que necesita &#8220;leer&#8221; un objeto sin modificarlo.<br />
Las funciones <strong>implícitas</strong> permiten conversiones automáticas. Específicamente permiten que una función se aplique en el momento justo en que ayude a satisfacer la inferencia de tipos, por ejemplo:</p>
<pre>
scala&gt; implicit def strToInt(x: String) = x.toInt
strToInt: (x: String)Int

scala&gt; "123"
res0: java.lang.String = 123

scala&gt; val y: Int = "123"
y: Int = 123

scala&gt; math.max("123", 111)
res1: Int = 123
</pre>
<p>Los límites de vistas como los límites de tipo precisan que tal función exista para un tipo especificado. Puedes declarar in límite de vista de la siguiente con este símbolo: <code>&lt;%</code> ejemplo:</p>
<pre>
scala&gt; class Container[A &lt;% Int] { def addIt(x: A) = 123 + x }
defined class Container
</pre>
<p>Esto nos dice que <strong>A</strong> tiene que ser &#8220;visible&#8221; como <strong>Int</strong>.  Intentémoslo:</p>
<pre>
scala&gt; (new Container[String]).addIt("123")
res11: Int = 246

scala&gt; (new Container[Int]).addIt(123) 
res12: Int = 246

scala&gt; (new Container[Float]).addIt(123.2F)
&lt;console&gt;:8: error: could not find implicit value for evidence parameter of type (Float) =&gt; Int
       (new Container[Float]).addIt(123.2)
        ^
</pre>
<h2 id="otherbounds">Otros límites de tipo</h2>
<p>Los métodos pueden reforzar límites de tipo más complejos por medio de parámetros implícitos. Por ejemplo, <code>List</code></p>
<p>Los métodos pueden reforzar límites de tipo más complejos, a través de parámetros implícitos. Por ejemplo, <code>List</code> soporta <code>sum</code> en contenidos numéricos pero no en otro tipo de contenidos. Ay, los tipos numéricos de Scala no comparten una superclase en común, por lo que no podemos podemos decir que <code>T &lt;: Number</code>. Para conseguirlo la librería math de Scala  <a href="http://www.azavea.com/blogs/labs/2011/06/scalas-numeric-type-class-pt-1/">define un <code>Numeric[T]</code> implícito para los tipos apropiados T</a>. Entonces lo utiliza en la definición de <code>List</code>:</p>
<pre>
sum[B &gt;: A](implicit num: Numeric[B]): B
</pre>
<p>Si invocas <code>List(1,2).sum()</code>, no necesitas pasar un parámetro <em>num</em>; puesto que ya está presente de forma implícita. Pero si invocas <code>List("whoop").sum()</code>, el compilador va a quejarse ya que no pudo asignar <code>num</code></p>
<p>Los métodos pueden requerir algunos tipos de evidencia específica para un tipo, sin meterse con objetos extraños como con <code>Numeric</code>. En su lugar, puedes usar uno de estos operadores de relación de tipos:</p>
<table>
	<tr>
		<td>A =:= B</td>
		<td>A igual a B</td>
	</tr>
	<tr>
		<td>A &lt;:&lt; B</td>
		<td>A subtipo de B</td>
	</tr>
	<tr>
		<td>A &lt;%&lt; B</td>
		<td>A visible como B</td>
	</tr>
</table>
<p>(Si obtienes errores intentando utilizar &lt;:&lt; o &lt;%&lt;, ten cuidado de aquellos errores que desaparecieron en Scala 2.10. Los ejemplos de Scala School funcionan con <a href="http://www.scala-lang.org/download/2.9.3.html">Scala 2.9.x</a> . Puedes usar una nueva versión de Scala, pero prepárate para algunos errores.)</p>
<pre>
scala&gt; class Container[A](value: A) { def addIt(implicit evidence: A =:= Int) = 123 + value }
defined class Container

scala&gt; (new Container(123)).addIt
res11: Int = 246

scala&gt; (new Container("123")).addIt
&lt;console&gt;:10: error: could not find implicit value for parameter evidence: =:=[java.lang.String,Int]
</pre>
<p>De forma similar, dado el valor implícito que acabamos de ver, podemos &#8220;relajar&#8221; la restricción de visibilidad:</p>
<pre>
scala&gt; class Container[A](value: A) { def addIt(implicit evidence: A &lt;%&lt; Int) = 123 + value }
defined class Container

scala&gt; (new Container("123")).addIt
res15: Int = 246
</pre>
<h3>Programación genérica con vistas</h3>
<p>En la librería estándar de Scala, las vistas son usadas principalmente para implementar funciones genéricas sobre colecciones. Por ejemplo, la función &#8220;min&#8221; (en <strong>Seq[]</strong>), usa la siguiente técnica:</p>
<pre>
def min[B &gt;: A](implicit cmp: Ordering[B]): A = {
  if (isEmpty)
    throw new UnsupportedOperationException("empty.min")

  reduceLeft((x, y) =&gt; if (cmp.lteq(x, y)) x else y)
}
</pre>
<p>Las principales ventajas son:</p>
<ul>
	<li>Los elementos en la colección no necesitan implementar <strong>Ordered</strong>, pero los tipos en cada uso de <strong>Ordered</strong> siguen siendo verificados estáticamente.</li>
	<li>Puedes definir tus propias ordenaciones sin usar librerías extra:</li>
</ul>
<pre>
scala&gt; List(1,2,3,4).min
res0: Int = 1

scala&gt; List(1,2,3,4).min(new Ordering[Int] { def compare(a: Int, b: Int) = b compare a })
res3: Int = 4
</pre>
<p>Como nota al pié, existen vistas en la librería estándar que traducen <strong>Ordered</strong> en <strong>Ordering</strong> (y vice versa).</p>
<pre>
trait LowPriorityOrderingImplicits {
  implicit def ordered[A &lt;: Ordered[A]]: Ordering[A] = new Ordering[A] {
    def compare(x: A, y: A) = x.compare(y)
  }
}
</pre>
<h4>Límites de contexto e implicit[]</h4>
<p>Scala 2.8 introdujo un atajo para enhebrar y acceder argumentos implícitos.</p>
<pre>
scala&gt; def foo[A](implicit x: Ordered[A]) {}
foo: [A](implicit x: Ordered[A])Unit

scala&gt; def foo[A : Ordered] {}                        
foo: [A](implicit evidence$1: Ordered[A])Unit
</pre>
<p>Los valores implícitos pueden ser accedidos a través de <strong>implicity</strong></p>
<pre>
scala&gt; implicitly[Ordering[Int]]
res37: Ordering[Int] = scala.math.Ordering$Int$@3a9291cf
</pre>
<p>Combinados, estas técnicas resultan frecuentemente en menos código, especialmente cuando enhebramos a través de vistas.</p>
<h2 id="higher">Tipos de orden superior y polimorfismo ad-hoc</h2>
<p>Scala puede abstraer tipos de &#8220;orden superior&#8221;. Por ejemplo, supongamos que necesitas usar varios tipos de contenedores para distintos tipos de datos. Para lograrlo podrías definir una interfaz <code>Container</code> que pueda implementarse por diferentes tipos de containers: <code>Option</code>, <code>List</code>, etc. Quieres definir una interfaz para poder utilizar valores en estos contenedores sin estropear el tipo del valor.</p>
<p>Esto es análogo al currying. Por ejemplo, mientras los &#8220;tipos unarios&#8221; tienen constructores como <code>List[A]</code>, donde tenemos que satisfacer un &#8220;nivel&#8221; de variables tipo para producir tipos concretos (de la misma forma en que una función a la que no se le ha aplicado currying necesita un solo argumento para ser invocada), los tipos de orden superior necesitan más.</p>
<pre>
scala&gt; trait Container[M[_]] { def put[A](x: A): M[A]; def get[A](m: M[A]): A }

scala&gt; val container = new Container[List] { def put[A](x: A) = List(x); def get[A](m: List[A]) = m.head }
container: java.lang.Object with Container[List] = $anon$1@7c8e3f75

scala&gt; container.put("hey")
res24: List[java.lang.String] = List(hey)

scala&gt; container.put(123)
res25: List[Int] = List(123)
</pre>
<p>Notemos que el <strong>Container</strong> es polimórfico en un tipo parametrizado (&#8220;Tipo contenedor&#8221;).<br />
Si combinamos el utilizar containers con implicits obtenemos un polimorfismo &#8220;ad-hoc&#8221;: el poder escribir funciones genéricas en contenedores.</p>
<pre>
scala&gt; trait Container[M[_]] { def put[A](x: A): M[A]; def get[A](m: M[A]): A }

scala&gt; implicit val listContainer = new Container[List] { def put[A](x: A) = List(x); def get[A](m: List[A]) = m.head }

scala&gt; implicit val optionContainer = new Container[Some] { def put[A](x: A) = Some(x); def get[A](m: Some[A]) = m.get }

scala&gt; def tupleize[M[_]: Container, A, B](fst: M[A], snd: M[B]) = {
     | val c = implicitly[Container[M]]                             
     | c.put(c.get(fst), c.get(snd))
     | }
tupleize: [M[_],A,B](fst: M[A],snd: M[B])(implicit evidence$1: Container[M])M[(A, B)]

scala&gt; tupleize(Some(1), Some(2))
res33: Some[(Int, Int)] = Some((1,2))

scala&gt; tupleize(List(1), List(2))
res34: List[(Int, Int)] = List((1,2))
</pre>
<h2 id="fbounded">Polimorfismo de límite F (F-bounded polymorphism)</h2>
<p>Algunas veces es necesario accesar a una clase concreta en un trait genérico. Por ejemplo, imagina que tienes un trait genérico pero tienes que compararlo con una subclase particular de ese trait.</p>
<pre>
trait Container extends Ordered[Container]
</pre>
<p>De cualquier forma, necesitamos el método compare:</p>
<pre>
def compare(that: Container): Int
</pre>
<p>Y entonces no podremos accesar al subtipo concreto, el siguiente código:</p>
<pre>
class MyContainer extends Container {
  def compare(that: MyContainer): Int
}
</pre>
<p>falla al compilar ya que estamos especificando Ordered para un <strong>Container</strong>, no para el subtipo particular.</p>
<p>Para arreglar esto, necesitamos el polimorfismo de límite F.</p>
<pre>
trait Container[A &lt;: Container[A]] extends Ordered[A]
</pre>
<p>Un poco raro, pero notemos como Ordered esta parametrizado con <strong>A</strong>, lo que en si mismo es un <strong>Container[A]</strong></p>
<p>Así que ahora</p>
<pre>
class MyContainer extends Container[MyContainer] { 
  def compare(that: MyContainer) = 0 
}
</pre>
<p>Están ordenados:</p>
<pre>
scala&gt; List(new MyContainer, new MyContainer, new MyContainer)
res3: List[MyContainer] = List(MyContainer@30f02a6d, MyContainer@67717334, MyContainer@49428ffa)

scala&gt; List(new MyContainer, new MyContainer, new MyContainer).min
res4: MyContainer = MyContainer@33dfeb30
</pre>
<p>Dado que todos ellos son subtipos de <strong>Container[_]</strong>, podemos definit otra subclase y crear una lista mezclada de <strong>Container[_]</strong>:</p>
<pre>
scala&gt; class YourContainer extends Container[YourContainer] { def compare(that: YourContainer) = 0 }
defined class YourContainer

scala&gt; List(new MyContainer, new MyContainer, new MyContainer, new YourContainer)                   
res2: List[Container[_ &gt;: YourContainer with MyContainer &lt;: Container[_ &gt;: YourContainer with MyContainer &lt;: ScalaObject]]] 
  = List(MyContainer@3be5d207, MyContainer@6d3fe849, MyContainer@7eab48a7, YourContainer@1f2f0ce9)
</pre>
<p>Note how the resulting type is now lower-bound by <strong>YourContainer with MyContainer</strong>. This is the work of the type inferencer. Interestingly- this type doesn&#8217;t even need to make sense, it only provides a logical greatest lower bound for the unified type of the list. What happens if we try to use <strong>Ordered</strong> now?</p>
<pre>
(new MyContainer, new MyContainer, new MyContainer, new YourContainer).min
&lt;console&gt;:9: error: could not find implicit value for parameter cmp:
  Ordering[Container[_ &gt;: YourContainer with MyContainer &lt;: Container[_ &gt;: YourContainer with MyContainer &lt;: ScalaObject]]]
</pre>
<p>No existe un <strong>Ordered[]</strong> para tipos unificados. Lamentablemente.</p>
<h2 id="structural">Tipos estructurales</h2>
<p>Scala soporta <strong>tipos estructurados</strong> &#8212; los requerimientos se expresan en la interfaz <em>structute</em> en lugar de de un tipo concreto.</p>
<pre>
scala&gt; def foo(x: { def get: Int }) = 123 + x.get
foo: (x: AnyRef{def get: Int})Int

scala&gt; foo(new { def get = 10 })                 
res0: Int = 133
</pre>
<p>Esto puede ser útil en muchos casos, pero la implementación usa reflexión, así que ten en cuenta la eficiencia.</p>
<h2 id="abstractmem">Miembros de tipos abstractos</h2>
<p>En un trait, puedes dejar que los miembros tipo sean abstract.</p>
<pre>
scala&gt; trait Foo { type A; val x: A; def getX: A = x }
defined trait Foo

scala&gt; (new Foo { type A = Int; val x = 123 }).getX   
res3: Int = 123

scala&gt; (new Foo { type A = String; val x = "hey" }).getX
res4: java.lang.String = hey
</pre>
<p>Es un truco útil cuando se hace inyección de dependencias por ejemplo.</p>
<p>Puedes referir a una variable de tipo abstracto utilizando el operador hash:</p>
<pre>
scala&gt; trait Foo[M[_]] { type t[A] = M[A] }
defined trait Foo

scala&gt; val x: Foo[List]#t[Int] = List(1)
x: List[Int] = List(1)
</pre>
<h2 id="manifest">Enmendaduras de tipo (erasures) y manifests</h2>
<p>ver: https://en.wikipedia.org/wiki/Type_erasure</p>
<p>Como sabemos, el tipo se pierde en tiempo de compilación debido al <em>erasure</em>. Scala soporta <strong>Manifests</strong>, lo que nos permite recuperar el tipo de forma selectiva. Los manifest se proveen como un valor implícito, generado por el compilador cuando se necesita.</p>
<pre>
scala&gt; class MakeFoo[A](implicit manifest: Manifest[A]) { def make: A = manifest.erasure.newInstance.asInstanceOf[A] }

scala&gt; (new MakeFoo[String]).make
res10: String = ""
</pre>
<h2 id="finagle">Caso de estudio: Finagle</h2>
<p>Ver: <a href="https://github.com/twitter/finagle">https://github.com/twitter/finagle</a></p>
<pre>
trait Service[-Req, +Rep] extends (Req =&gt; Future[Rep])

trait Filter[-ReqIn, +RepOut, +ReqOut, -RepIn]
  extends ((ReqIn, Service[ReqOut, RepIn]) =&gt; Future[RepOut])
{
  def andThen[Req2, Rep2](next: Filter[ReqOut, RepIn, Req2, Rep2]) =
    new Filter[ReqIn, RepOut, Req2, Rep2] {
      def apply(request: ReqIn, service: Service[Req2, Rep2]) = {
        Filter.this.apply(request, new Service[ReqOut, RepIn] {
          def apply(request: ReqOut): Future[RepIn] = next(request, service)
          override def release() = service.release()
          override def isAvailable = service.isAvailable
        })
      }
    }
    
  def andThen(service: Service[ReqOut, RepIn]) = new Service[ReqIn, RepOut] {
    private[this] val refcounted = new RefcountedService(service)

    def apply(request: ReqIn) = Filter.this.apply(request, refcounted)
    override def release() = refcounted.release()
    override def isAvailable = refcounted.isAvailable
  }    
}
</pre>
<p>Un servicio puede autenticar peticiones con un filtro.</p>
<pre>
trait RequestWithCredentials extends Request {
  def credentials: Credentials
}

class CredentialsFilter(credentialsParser: CredentialsParser)
  extends Filter[Request, Response, RequestWithCredentials, Response]
{
  def apply(request: Request, service: Service[RequestWithCredentials, Response]): Future[Response] = {
    val requestWithCredentials = new RequestWrapper with RequestWithCredentials {
      val underlying = request
      val credentials = credentialsParser(request) getOrElse NullCredentials
    }

    service(requestWithCredentials)
  }
}
</pre>
<p>Notemos como el el servicio subyacente requiere una petición autenticada, y que esté estadísticamente verificada. Por ello los filtros pueden pensarse como transformadores de servicios.</p>
<p>Varios filtros pueden aplicarse al mismo tiempo:</p>
<pre>
val upFilter =
  logTransaction     andThen
  handleExceptions   andThen
  extractCredentials andThen
  homeUser           andThen
  authenticate       andThen
  route
</pre>
<p>Haz tipos seguros!</p>
    </div> <!-- /container -->

    <div id="footer">
      <div class="inner">
        <div class="container">
          <p>

          Built at <a href="http://twitter.com/twitter"
          target="_blank">@twitter</a> by
          <a href="http://twitter.com/stevej" target="_blank">@stevej</a>,
          <a href="http://twitter.com/marius" target="_blank">@marius</a>, and
          <a href="http://twitter.com/lahosken" target="_blank">@lahosken</a>
          with much help from
          <a href="http://twitter.com/evanm" target="_blank">@evanm</a>,
          <a href="http://twitter.com/sprsquish"
          target="_blank">@sprsquish</a>,
          <a href="http://twitter.com/kevino" target="_blank">@kevino</a>,
          <a href="http://twitter.com/zuercher" target="_blank">@zuercher</a>,
          <a href="http://twitter.com/timtrueman"
          target="_blank">@timtrueman</a>,
          <a href="http://twitter.com/wickman" target="_blank">@wickman</a>,
          and <a href="http://twitter.com/mccv" target="_blank">@mccv</a>;
          Russian translation by
          <a href="https://github.com/appigram">appigram</a>;
          Chinese simple translation by
          <a href="https://github.com/jasonqu">jasonqu</a>;
          Korean translation by
          <a href="https://github.com/enshahar">enshahar</a>;<br />
          <br />

          Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>.
          </p>
        </div>
      </div>
    </div>

  </body>
</html>
