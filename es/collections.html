<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Scala School - Colecciones</title>
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link rel="stylesheet" href="/scala_school/bootstrap-1.1.0.min.css">
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-39101739-7', 'twitter.github.io');
      ga('send', 'pageview');

    </script>
  </head>

  <body>
  
    <div class="topbar">
      <div class="fill">
        <div class="container fixed">
          <h3><a href="index.html">Colecciones</a></h3>
          <ul class="nav secondary-nav">
            
              <li><a href="basics2.html">&laquo;Previous</a></li>
            
            
              <li><a href="pattern-matching-and-functional-composition.html">Next&raquo;</a></li>
            
          </ul>

        </div>
      </div>
    </div>

    <div class="container" style="padding-top: 60px;">
      <p>Esta lección contempla:</p>
<ul>
	<li>Basic Data Structures</li>
	<li>Estructuras de Datos básicas
	<ul>
		<li><a href="#Lists">Listas</a></li>
		<li><a href="#Sets">Conjuntos</a></li>
		<li><a href="#Tuple">Tupla</a></li>
		<li><a href="#Maps">Maps</a></li>
		<li><a href="#Option">Option</a></li>
	</ul></li>
	<li>Combinadores funcionales
	<ul>
		<li><a href="#map">map</a></li>
		<li><a href="#foreach">foreach</a></li>
		<li><a href="#filter">filter</a></li>
		<li><a href="#zip">zip</a></li>
		<li><a href="#partition">partition</a></li>
		<li><a href="#find">find</a></li>
		<li><a href="#drop">drop y dropWhile</a></li>
		<li><a href="#fold">foldLeft y foldRight</a></li>
		<li><a href="#flatten">flatten</a></li>
		<li><a href="#flatMap">flatMap</a></li>
		<li><a href="#generalized">Generalized functional combinators</a></li>
		<li><a href="#vsMap">Map?</a></li>
	</ul></li>
</ul>
<h1>Estructuras basicas de datos</h1>
<p>Scala provee algunas colecciones.</p>
<p><strong>Véase tambien</strong> en Effective Scala que tiene información acerca de como usar <a href="http://twitter.github.com/effectivescala/#Collections">colecciones</a>.</p>
<h2 id="Lists">Listas</h2>
<pre>
scala&gt; val numeros = List(1, 2, 3, 4)
numeros: List[Int] = List(1, 2, 3, 4)
</pre>
<h2 id="Sets">Conjuntos</h2>
<p>Los conjuntos no pueden tener duplicados.</p>
<pre>
scala&gt; Set(1, 1, 2)
res0: scala.collection.immutable.Set[Int] = Set(1, 2)
</pre>
<h2 id="Tuple">Tupla</h2>
<p>Una tupla agrupa colecciones lógicas simples de elementos sin usar una clase.</p>
<pre>
scala&gt; val hostPort = ("localhost", 80)
hostPort: (String, Int) = (localhost, 80)
</pre>
<p>A diferencia de las clases caso, no tienen métodos de acceso nombrados, en su lugar tienen metodos de acceso que son nombrados por su posición y esta basado en índice 1 en vez de 0.</p>
<pre>
scala&gt; hostPort._1
res0: String = localhost

scala&gt; hostPort._2
res1: Int = 80
</pre>
<p>Las tuplas encajan con &#8220;pattern matching&#8221; perfectamente.</p>
<pre>
hostPort match {
  case ("localhost", port) =&gt; ...
  case (host, port) =&gt; ...
}
</pre>
<p>Las tuplas tienen la facilidad de simplificar su implementación con 2 valores utilizando: <code>-&gt;</code>.</p>
<pre>
scala&gt; 1 -&gt; 2
res0: (Int, Int) = (1,2)
</pre>
<p><strong>Véase tambien</strong> Effective Scala que tiene contenido  acerca de <a href="http://twitter.github.com/effectivescala/#Functional programming-Destructuring bindings">como desestructurar enlaces</a> (&#8220;desempaquetar una tupla&#8221;).</p>
<h2 id="Maps">Maps</h2>
<p>Pueden contener tipos basicos de datos.</p>
<pre>
Map(1 -&gt; 2)
Map("foo" -&gt; "bar")
</pre>
<p>Esto se ve como una sintáxis especial pero recuerda lo que se dijo de la tupla que <code>-&gt;</code>  puede ser usado para crear tuplas.</p>
<p><code>Map()</code> tambien usa la sintáxis de argumentos que aprendimos en la leccion #1: <code> Map(1 -&gt; "one", 2 -&gt; "two") </code> la cual se usa dentro de <code> Map((1, "one"), (2, "two")) </code> con el primer siendo la clave y el segundo siendo el valor del Map.</p>
<p>Los &#8220;Maps&#8221; tambien pueden contener &#8220;Maps&#8221; o incluso funciones como valores.</p>
<pre>
Map(1 -&gt; Map("foo" -&gt; "bar"))
</pre>

<pre>
Map("timesTwo" -&gt; { timesTwo(_) })
</pre>
<h2 id="Option">Option</h2>
<p><code>Option</code> es un contenedor que puede o no contener algún elemento.</p>
<p>La interfaz basica de Option se ve así:</p>
<pre>
trait Option[T] {
  def isDefined: Boolean
  def get: T
  def getOrElse(t: T): T
}
</pre>
<p>Option en si misma es generica y tiene dos subclases: <code>Some[T]</code> o <code>None</code>.</p>
<p>Veamos un ejemplo de como se usa Option:</p>
<p><code>Map.get</code> usa <code>Option</code> como su tipo de retorno. Option te ayuda a saber que el metodo puede no retornar lo que estas solicitando.</p>
<pre>
scala&gt; val numbers = Map("one" -&gt; 1, "two" -&gt; 2)
numbers: scala.collection.immutable.Map[java.lang.String,Int] = Map(one -&gt; 1, two -&gt; 2)

scala&gt; numbers.get("two")
res0: Option[Int] = Some(2)

scala&gt; numbers.get("three")
res1: Option[Int] = None
</pre>
<p>Ahora nuestros datos aparecen atrapados en <code>Option</code>. ¿Como lidiamos con esto?.</p>
<p>Un primer instinto podria ser usar un condicional basado en el metodo <code>IsDefined</code>.</p>
<pre>
// We want to multiply the number by two, otherwise return 0.
val result = if (res1.isDefined) {
  res1.get * 2
} else {
  0
}
</pre>
<p>Te sugerimos utilizar <code>getOrElse</code> o coincidencia  de patrones (pattern matching) para lidiar con este resultado.<br />
<code>getOrElse</code> también te permite facilmente definir un valor por defecto.</p>
<pre>
val result = res1.getOrElse(0) * 2
</pre>
<p>La coincidencia de patrones (pattern matching) se adapta naturalmente con <code>Option</code>.</p>
<pre>
val result = res1 match {
  case Some(n) =&gt; n * 2
  case None =&gt; 0
}
</pre>
<p><strong>Véase tambien</strong> en Effective Scala que tiene contenido acerca de <a href="http://twitter.github.com/effectivescala/#Functional programming-Options">Options</a>.</p>
<h1 id="combinators">Combinadores funcionales</h1>
<p><code>List(1, 2, 3) map squared</code> aplica la función <code>squared</code> a los elementos de la lista, regresando una nueva lista, por ejemplo <code>List(1, 4, 9)</code>. Llamamos operaciones como <em>combinadores</em> <code>map</code>. Si tu prefieres una mejor definicion, puedes ver  <a href="http://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man">Explanation of combinators</a> en Stackoverflow. Su uso mas comun es en estructuras de datos  estandar.</p>
<h2 id="map">map</h2>
<p>Evalua una función sobre cada elemento de la lista, retornando una lista con el mismo numero de elementos.</p>
<pre>
scala&gt; numbers.map((i: Int) =&gt; i * 2)
res0: List[Int] = List(2, 4, 6, 8)
</pre>
<p>o pasa en una función (el compilador de scala automaticamente convierte nuestro metodo a una función).</p>
<pre>
scala&gt; def timesTwo(i: Int): Int = i * 2
timesTwo: (i: Int)Int

scala&gt; numbers.map(timesTwo)
res0: List[Int] = List(2, 4, 6, 8)
</pre>
<h2 id="foreach">foreach</h2>
<p>foreach es como map pero no retorna nada. foreach esta destinada unicamente a efectos secundarios.</p>
<pre>
scala&gt; numbers.foreach((i: Int) =&gt; i * 2)
</pre>
<p>La función entonces no retorna nada.</p>
<p>tu puedes tratar de guardar lo que retorna en un valor pero sera de tipo Unit (similar a void).</p>
<pre>
scala&gt; val doubled = numbers.foreach((i: Int) =&gt; i * 2)
doubled: Unit = ()
</pre>
<h2 id="filter">filter</h2>
<p>Elimina cualquier elemento donde la función que pasaste retorna un false. Las funciones que retornan un Boolean son a menudo llamadas funciones predicado y evaluan para la inclusión de los elementos.</p>
<pre>
scala&gt; numbers.filter((i: Int) =&gt; i % 2 == 0)
res0: List[Int] = List(2, 4)
</pre>

<pre>
scala&gt; def isEven(i: Int): Boolean = i % 2 == 0
isEven: (i: Int)Boolean

scala&gt; numbers.filter(isEven _)
res2: List[Int] = List(2, 4
</pre>
<h2 id="zip">zip</h2>
<p><code>zip</code> agrega los contenidos de 2 listas en una lista de pares.</p>
<pre>
scala&gt; List(1, 2, 3).zip(List("a", "b", "c"))
res0: List[(Int, String)] = List((1,a), (2,b), (3,c))
</pre>
<h2 id="partition">partition</h2>
<p><code>partition</code> divide una lista de acuerdo con una función predicado.</p>
<pre>
scala&gt; val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
scala&gt; numbers.partition(_ % 2 == 0)
res0: (List[Int], List[Int]) = (List(2, 4, 6, 8, 10),List(1, 3, 5, 7, 9))
</pre>
<h2 id="find">find</h2>
<p><code>find</code> regresa el primer elemento de una coleccion que coincide con una función predicado.</p>
<pre>
scala&gt; numbers.find((i: Int) =&gt; i &gt; 5)
res0: Option[Int] = Some(6)
</pre>
<h2 id="drop">drop &amp; dropWhile</h2>
<p><code>drop</code> elimina el primer elemento i.</p>
<pre>
scala&gt; numbers.drop(5)
res0: List[Int] = List(6, 7, 8, 9, 10)
</pre>
<p><code>dropwhile</code> elimina los primeros elementos que coinciden con una función predicado mientras sea verdadera. Por ejemplo, si hacemos <code>dropwhile</code> con una función predicado de numeros impares, en nuestra lista de numeros, el numero <code>1</code> se elimina (pero no el <code>3</code>  porque esta protegido por el numero <code>2</code>).</p>
<pre>
scala&gt; numbers.dropWhile(_ % 2 != 0)
res0: List[Int] = List(2, 3, 4, 5, 6, 7, 8, 9, 10)
</pre>
<h2 id="fold">foldLeft y foldRight</h2>
<h3>foldLeft<br />
<pre><br />
scala&gt; numbers.foldLeft(0)((m: Int, n: Int) =&gt; m + n)<br />
res0: Int = 55<br />
</pre></h3>
<p>0 es el valor de comienzo (recuerda que los numeros son una lista List[Int]), y m actua como un acumulador.</p>
<p>Veámoslo:</p>
<pre>
scala&gt; numbers.foldLeft(0) { (m: Int, n: Int) =&gt; println("m: " + m + " n: " + n); m + n }
m: 0 n: 1
m: 1 n: 2
m: 3 n: 3
m: 6 n: 4
m: 10 n: 5
m: 15 n: 6
m: 21 n: 7
m: 28 n: 8
m: 36 n: 9
m: 45 n: 10
res0: Int = 55
</pre>
<h3>foldRight</h3>
<p>Es lo mismo que foldleft excepto que corre en la direccion opuesta</p>
<pre>
scala&gt; numbers.foldRight(0) { (m: Int, n: Int) =&gt; println("m: " + m + " n: " + n); m + n }
m: 10 n: 0
m: 9 n: 10
m: 8 n: 19
m: 7 n: 27
m: 6 n: 34
m: 5 n: 40
m: 4 n: 45
m: 3 n: 49
m: 2 n: 52
m: 1 n: 54
res0: Int = 55
</pre>
<h2 id="flatten">flatten</h2>
<p><code>flatten</code> colapsa a un nivel una estructura anidada</p>
<pre>
scala&gt; List(List(1, 2), List(3, 4)).flatten
res0: List[Int] = List(1, 2, 3, 4)
</pre>
<h2 id="flatMap">flatMap</h2>
<p><code>flatMap</code> es un combinador frecuentemente usado que combina mapping y flattening. <code>flatMap</code> toma una función que trabaja sobre una la lista anidada y concatena el resultado en una nueva lista</p>
<pre>
scala&gt; val nestedNumbers = List(List(1, 2), List(3, 4))
nestedNumbers: List[List[Int]] = List(List(1, 2), List(3, 4))

scala&gt; nestedNumbers.flatMap(x =&gt; x.map(_ * 2))
res0: List[Int] = List(2, 4, 6, 8)
</pre>
<p>Piensa en esto como una forma abreviada para hacer mapping y despues flattening:</p>
<pre>
scala&gt; nestedNumbers.map((x: List[Int]) =&gt; x.map(_ * 2)).flatten
res1: List[Int] = List(2, 4, 6, 8)
</pre>
<p>El ejemplo llamando map y despues flatten es un ejemplo de &#8220;combinador&#8221; como algo natural de estas funciones.</p>
<p><strong>Véase tambien</strong> Effective Scala que tiene documentaion acerca de <a href="http://twitter.github.com/effectivescala/#Functional programming-`flatMap`">flatMap</a>.</p>
<h2 id="generalized">Generalized functional combinators</h2>
<p>Ahora que hemos aprendido varias funciones para trabajar con colecciones nos gustaria ser capaces de escribir nuestros propios combinadores funcionales.<br />
Es interesante que cada combinador funcional que se muestra arriba puede ser escrito con funciones <code>fold</code>. Veamos algunos ejemplos:</p>
<pre>
def ourMap(numbers: List[Int], fn: Int =&gt; Int): List[Int] = {
  numbers.foldRight(List[Int]()) { (x: Int, xs: List[Int]) =&gt;
    fn(x) :: xs
  }
}

scala&gt; ourMap(numbers, timesTwo(_))
res0: List[Int] = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)
</pre>
<p>¿Por qué <code>List[Int]()</code>? Scala no fue lo suficientemente inteligente para notar que tu querías una lista vacia de enteros para acumular informacion.</p>
<h2 id="vsMap">Map?</h2>
<p>Todos los combinadores funcionales mostrados tambien trabajan sobre Maps, los Maps pueden ser pensados como una lista de pares, así las funciones que escribes trabajan en una pareja de llaves y valores en el Map.</p>
<pre>
scala&gt; val extensions = Map("steve" -&gt; 100, "bob" -&gt; 101, "joe" -&gt; 201)
extensions: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101), (joe,201))
</pre>
<p>Ahora filtrar cada entrada cuya extensión telefónica es inferior a 200.</p>
<pre>
scala&gt; extensions.filter((namePhone: (String, Int)) =&gt; namePhone._2 &lt; 200)
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
</pre>
<p>Porque le da una tupla, tienes que sacar las claves y valores con sus descriptores de acceso posicionales. ¡Qué asco!</p>
<p>Por suerte, podemos usar una coincidencia de patrón para extraer la clave y el valor fácilmente.</p>
<pre>
scala&gt; extensions.filter({case (name, extension) =&gt; extension &lt; 200})
res0: scala.collection.immutable.Map[String,Int] = Map((steve,100), (bob,101))
</pre>
<p>¿Por qué funciona esto? ¿Por qué puedes pasar un patrón de coincidencia en un parcial?</p>
<p>permanece al pendiente para la siguiente semana!</p>
    </div> <!-- /container -->

    <div id="footer">
      <div class="inner">
        <div class="container">
          <p>

          Built at <a href="http://twitter.com/twitter"
          target="_blank">@twitter</a> by
          <a href="http://twitter.com/stevej" target="_blank">@stevej</a>,
          <a href="http://twitter.com/marius" target="_blank">@marius</a>, and
          <a href="http://twitter.com/lahosken" target="_blank">@lahosken</a>
          with much help from
          <a href="http://twitter.com/evanm" target="_blank">@evanm</a>,
          <a href="http://twitter.com/sprsquish"
          target="_blank">@sprsquish</a>,
          <a href="http://twitter.com/kevino" target="_blank">@kevino</a>,
          <a href="http://twitter.com/zuercher" target="_blank">@zuercher</a>,
          <a href="http://twitter.com/timtrueman"
          target="_blank">@timtrueman</a>,
          <a href="http://twitter.com/wickman" target="_blank">@wickman</a>,
          and <a href="http://twitter.com/mccv" target="_blank">@mccv</a>;
          Russian translation by
          <a href="https://github.com/appigram">appigram</a>;
          Chinese simple translation by
          <a href="https://github.com/jasonqu">jasonqu</a>;
          Korean translation by
          <a href="https://github.com/enshahar">enshahar</a>;<br />
          <br />

          Licensed under the <a href="http://www.apache.org/licenses/LICENSE-2.0" target="_blank">Apache License v2.0</a>.
          </p>
        </div>
      </div>
    </div>

  </body>
</html>
